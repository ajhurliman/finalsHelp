var uuid = require('node-uuid');

function ProcessScanner(agent) {
  this.agent = agent;
  this.autoSnapshotDurationSeconds = 10;
  this.snapshotCount = 0;
  this.maxSnapshotsPerPeriod = 2;
  this.snapshotCountResetPeriodMS = 1 * 60 * 1000;
  this.snapshotsResetIntervalId = undefined;
  this.currentProcessSnapshot = undefined;
  this.lastProcessRequestId = undefined;
  this.btCalls = null;
}

exports.ProcessScanner = ProcessScanner;

ProcessScanner.prototype.init = function () {
  var self = this;

  var snapshotsPerPeriod =
    self.agent.opts.maxProcessSnapshotsPerPeriod;

  if (snapshotsPerPeriod !== undefined) {
    snapshotsPerPeriod = +snapshotsPerPeriod;
    if (snapshotsPerPeriod >= 0) {
      self.maxSnapshotsPerPeriod = snapshotsPerPeriod;
    }
  }

  self.agent.logger.log("ProcessScanner - maxSnapshotsPerPeriod: " + self.maxSnapshotsPerPeriod);

  var resetPeriod = +(self.agent.opts.processSnapshotCountResetPeriodSeconds);
  if (resetPeriod && (resetPeriod > 0)) {
    self.snapshotCountResetPeriodMS = (+resetPeriod) * 1000;
  }
  self.agent.logger.log("ProcessScanner - snapshotCountResetPeriodMS: " + self.snapshotCountResetPeriodMS);

  var snapshotDuration = +(self.agent.opts.autoSnapshotDurationSeconds);
  if (snapshotDuration && (snapshotDuration > 0) && (snapshotDuration < 300)) {
    self.autoSnapshotDurationSeconds = snapshotDuration;
  }
  self.agent.logger.log("ProcessScanner - autoSnapshotDurationSeconds: " + self.autoSnapshotDurationSeconds);

  self.agent.on('transactionStarted', function(transaction, req) {
    if (!self.capturingProcessSnapshot) return;
    var threadId = transaction.threadId;
    var btCallInfo = self.btCalls[threadId] || (self.btCalls[threadId] = {});
    btCallInfo.startTime = self.agent.system.hrtime();
    btCallInfo.registrationId = transaction.registrationId;
    transaction.addProcessSnapshotGUID(self.currentProcessSnapshot.guid);
  });

  self.agent.on('transaction', function(transaction) {
    if (!self.capturingProcessSnapshot) return;

    transaction.addProcessSnapshotGUID(self.currentProcessSnapshot.guid);
    var threadId = transaction.threadId;
    var btCallInfo = self.btCalls[threadId] || (self.btCalls[threadId] = { startTime : undefined });
    btCallInfo.registrationId = btCallInfo.registrationId || transaction.registrationId;
    btCallInfo.endTime = self.agent.system.hrtime();
  });
}

Object.defineProperty(ProcessScanner.prototype, 'capturingProcessSnapshot', {
    get: function(){
        return !!this.currentProcessSnapshot;
    }
});

function ensureInterval(self) {
  if (self.snapshotsResetIntervalId)
    return;
  self.snapshotsResetIntervalId = self.agent.timers.setInterval(function () {
    self.snapshotCount = 0;
  }, self.snapshotCountResetPeriodMS);
}

// translate an undefined callback to a function that
// logs errors and sends the process snapshot to the proxy
// on success.
function ensureCallback(self, callback)
{
  return callback || function (err, processSnapshot) {
    if (err) {
      self.agent.logger.error(err);
      return;
    }
    self.agent.proxyTransport.sendProcessSnapshot(processSnapshot);
  };
}

ProcessScanner.prototype.doErrorCallback = function(msg, callback)
{
    if (!callback) {
        return;
    }

    var err = new Error(msg);
    process.nextTick(function() { callback(err, null); });
}

ProcessScanner.prototype.startAutoSnapshotIfPossible = function (callback) {
  var self = this;
  if (self.capturingProcessSnapshot) {
    var msg = 'Process snapshot already in progress, not starting another one!';
    self.agent.logger.log(msg);
    self.doErrorCallback(msg, callback);
    return;
  }

  if (self.snapshotCount >= self.maxSnapshotsPerPeriod) {
    var msg = 'Already did '
        + self.snapshotCount
        + ' process snapshots in '
        + self.snapshotCountResetPeriodMS
        + 'ms.'
    self.agent.logger.log(msg);
    self.doErrorCallback(msg, callback);
    return;
  }

  self.startSnapshot(self.autoSnapshotDurationSeconds, -1, ensureCallback(self, callback));
}

ProcessScanner.prototype.startManualSnapshot = function(processCallGraphReq, callback) {
  var self = this, requestID;

  requestID = +processCallGraphReq.snapshotRequestID;
  if(requestID <= self.lastSnapshotRequestID) {
    var msg = 'snapshotRequestID '
        + processCallGraphReq.snapshotRequestID
        + ' was already processed, ignoring.';
    self.agent.logger.error(msg);
    self.doErrorCallback(msg, callback);
    return;
  }

  self.lastSnapshotRequestID = requestID;

  if (self.capturingProcessSnapshot) {
    var msg = 'Process snapshot capture already in progress; snapshotRequestID '
        + processCallGraphReq.snapshotRequestID
        + ' ignored.'
    self.agent.logger.error(msg);
    self.doErrorCallback(msg, callback);
    return;
  }

  self.startSnapshot(processCallGraphReq.captureTime, requestID, ensureCallback(self, callback));
}

ProcessScanner.prototype.__populatePendingTransactions = function() {
  var self = this
  var startTime = self.agent.system.hrtime();
  var transactionsMap = self.agent.profiler.transactions;
  self.btCalls = {};
  for(var threadId in transactionsMap) {
      var btCallInfo = self.btCalls[threadId] || ( self.btCalls[threadId] = {} );
      btCallInfo.startTime = startTime;
      btCallInfo.registrationId =
        btCallInfo.registrationId || transactionsMap[threadId].registrationId;
  }
}

ProcessScanner.prototype.__btCallsToProto = function(btCalls) {
  var self = this;
  var result = [];
  var registrationIDToIndex = {};
  var now = self.agent.system.hrtime();
  for (var threadId in btCalls) {
    var btCallInfo = btCalls[threadId];
    if (btCallInfo.startTime === undefined)
      continue;
    if (!btCallInfo.registrationId)
      continue;
    if (btCallInfo.endTime === undefined)
      btCallInfo.endTime = now;

    var index = registrationIDToIndex[btCallInfo.registrationId];
    if (index === undefined) {
      index = result.length;
      registrationIDToIndex[btCallInfo.registrationId] = index;
    }

    var protoBTCallInfo =
      result[index] || ( result[index] = { btID: btCallInfo.registrationId, count: 0, totalTimeTakenMS: 0 } );

    protoBTCallInfo.count++;
    protoBTCallInfo.totalTimeTakenMS +=
      Math.max(0, (btCallInfo.endTime - btCallInfo.startTime) / 1000.0);
  }
  return result;
}

ProcessScanner.prototype.startSnapshot = function (durationSeconds,
                                                   requestID,
                                                   callback) {
  var self = this;

  if(process.version.match(/^v0\.12\.[1234]$/) && !self.agent.opts.ignoreV8SamplerBug) {
    var msg = "CPU profiling is not supported in Node.js v0.12.x due to V8 bug.";
    self.doErrorCallback(msg, callback);
    return;
  }

  if (self.capturingProcessSnapshot) {
    var msg = "Process snapshot already started, not starting another.";
    self.doErrorCallback(msg, callback);
    return;
  }

  self.__populatePendingTransactions();

  self.currentProcessSnapshot = {
      snapshotRequestID: requestID,
      guid : uuid.v4(),
      timestamp : undefined,
      processCallgraph : undefined,
      processID : process.pid,
      btCalls : undefined
  };
  self.snapshotCount++;
  ensureInterval(self);

  self.agent.proxy.enableCallContext();

  process.nextTick(function() {
    try {
      self.agent.cpuProfiler.startCpuProfiler(durationSeconds, function(err, processCallGraph) {
        try {
          if(err) {
            callback(err, null);
            return;
          }

          var btCalls = self.__btCallsToProto(self.btCalls);

          var processSnapshot = self.currentProcessSnapshot;
          processSnapshot.timestamp = Date.now();
          processSnapshot.processCallGraph = processCallGraph;
          processSnapshot.btCalls = btCalls;

          self.lastSnapshotRequestID = requestID;

          self.postProcessCallGraph(processSnapshot, self.agent.proxy.getCallContextMap(), durationSeconds);

          callback(null, processSnapshot);
        } finally {
          self.btCalls = null;
          self.currentProcessSnapshot = undefined;
          self.agent.proxy.disableCallContext();
        }
      });
      self.agent.profiler.processSnapshotStarted(self.currentProcessSnapshot);
    }
    catch(err) {
      self.btCalls = null;
      self.currentProcessSnapshot = undefined;
      self.agent.proxy.disableCallContext();
      callback(err, null);
      return;
    }
  });
}

ProcessScanner.prototype.convertListToTree = function(elements) {
  var nodeQueue = [];
  var rootNode = elements.shift();
  nodeQueue.push(rootNode);

  while(nodeQueue.length > 0) {
    var node = nodeQueue.shift();
    node.children = [];

    for(var i = 0; i < node.numChildren; i++) {
      var childNode = elements.shift();
      node.children.push(childNode);
      nodeQueue.push(childNode);
    }

    delete node.numChildren;
  }

  return rootNode;
}


ProcessScanner.prototype.convertTreeToList = function(rootNode) {
  var elements = [];
  var nodeQueue = [];

  nodeQueue.push(rootNode);

  while(nodeQueue.length > 0) {
    var node = nodeQueue.shift();

    node.children.forEach(function(childNode) {
      nodeQueue.push(childNode);
    });

    node.numChildren = node.children.length;
    delete node.children;
    elements.push(node);
  }

  return elements;
}


ProcessScanner.prototype.calculateCpuTime = function(rootNode, durationSeconds) {
  var id = 1;
  var parentNodeMap = {};
  var nodeQueue = [];
  var reverseQueue = [];

  rootNode._id = id++;
  nodeQueue.push(rootNode);

  while(nodeQueue.length > 0) {
    var node = nodeQueue.shift();

    reverseQueue.unshift(node);

    for(i = node.children.length - 1; i >= 0; i--) {
      node.children[i]._id = id++;

      parentNodeMap[node.children[i]._id] = node;

      nodeQueue.unshift(node.children[i]);
    }
  }

  reverseQueue.forEach(function(node) {
    var parentNode = parentNodeMap[node._id];
    if(parentNode) {
      parentNode.samplesCount += node.samplesCount;
    }
  });

  var samplingRate = 1; //ms
  reverseQueue.forEach(function(node) {
    node.timeTaken = node.samplesCount * samplingRate;
  });

  reverseQueue.forEach(function(node) {
    delete node._id;
    delete node.samplesCount;
  });
}


ProcessScanner.prototype.populateCallContext = function(rootNode, callContextMap) {
  var i;
  var nodeQueue = [rootNode];
  var appdCallbackPrefix = /appd_proxy_/;

  while(nodeQueue.length > 0) {
    var node = nodeQueue.shift();

    if(node.method) {
      var callContext = callContextMap[node.method];
      if(callContext) {
        node.btId = callContext.btId;
        if(callContext.snapshotGuid) {
          node.snapshotGuid = callContext.snapshotGuid;
        }
      }
    }

    if(appdCallbackPrefix.exec(node.method)) {
      // don't need thread specific nodes anymore
      node.method = 'appd_proxy_x';
      node.lineNumber = 1;
    }

    for(i = node.children.length - 1; i >= 0; i--) {
      var childNode = node.children[i];

      if(node.btId) {
        childNode.btId = node.btId;
      }

      if(node.snapshotGuid) {
        childNode.snapshotGuid = node.snapshotGuid;
      }

      nodeQueue.unshift(childNode);
    }
  }
}

ProcessScanner.prototype.addBtData = function(firstNode, childNode) {
  var btData;

  if(childNode.btId) {
    if(!firstNode.procCallElemBTData) {
      firstNode.procCallElemBTData = [];
    }
    else {
      firstNode.procCallElemBTData.forEach(function(existingBtData) {
        if(existingBtData.btID === childNode.btId &&
            existingBtData.btSnapGUID === childNode.snapshotGuid) {
          btData = existingBtData;
        }
      })
    }

    if(btData) {
      btData.totalTimeTaken += childNode.timeTaken;
      btData.count++;
    }
    else {
      var btData = {
        btID: childNode.btId,
        count: 1,
        totalTimeTaken: childNode.timeTaken
      };

      if(childNode.snapshotGuid) {
        btData.btSnapGUID = childNode.snapshotGuid;
      }

      firstNode.procCallElemBTData.push(btData);
    }

    delete childNode.btId;
    delete childNode.snapshotGuid;
  }
}


ProcessScanner.prototype.mergeThreadPaths = function(rootNode) {
  var self = this;

  var i;
  var nodeQueue = [];
  nodeQueue.push(rootNode);

  while(nodeQueue.length > 0) {
    var node = nodeQueue.shift();
    var nodeMap = {};

    for(i = node.children.length - 1; i >= 0; i--) {
      var childNode = node.children[i];

      var sig = [
          childNode.klass,
          childNode.method,
          childNode.lineNumber,
          childNode.fileName
        ].join(':');

      var firstNode = nodeMap[sig];
      if(!firstNode) {
        nodeMap[sig] = childNode;

        self.addBtData(childNode, childNode);

        nodeQueue.unshift(childNode);
      }
      else {
        node.children.splice(i, 1);

        firstNode.timeTaken += childNode.timeTaken;
        self.addBtData(firstNode, childNode);

        childNode.children.forEach(function(childChildNode) {
          firstNode.children.push(childChildNode);
        });
      }
    }
  }
}


ProcessScanner.prototype.removeIdleNode = function(rootNode) {
  for(var i = 0; i < rootNode.children.length; i++) {
    if(rootNode.children[i].method === '(program)') {
      rootNode.children.splice(i, 1);
      break;
    }
  }
}


ProcessScanner.prototype.removeAgentNodes = function(rootNode) {
  var appdRegex = /\/appdynamics\//;

  var i;
  var nodeQueue = [];
  nodeQueue.push(rootNode);

  while(nodeQueue.length > 0) {
    var node = nodeQueue.shift();

    var childNodeQueue = node.children;
    node.children = [];

    while(childNodeQueue.length > 0) {
      var childNode = childNodeQueue.shift();

      if(appdRegex.exec(childNode.fileName)) {
        for(i = childNode.children.length - 1; i >= 0; i--) {
          childNodeQueue.unshift(childNode.children[i]);
        }
      }
      else {
        node.children.push(childNode);
      }
    }

    for(i = node.children.length - 1; i >= 0; i--) {
      nodeQueue.unshift(node.children[i]);
    }
  }
}



ProcessScanner.prototype.backpropagateCallContext = function(rootNode) {
  var self = this;

  function createBtDataUid(btData) {
    var btDataKey = btData.btID;

    if(btData.btSnapGUID) {
      btDataKey += ':' + btData.btSnapGUID;
    }

    return btDataKey;
  }


  function cloneBtData(btData) {
    var btDataCopy = {
      btID: btData.btID,
      count: btData.count,
      totalTimeTaken: btData.totalTimeTaken
    };

    if(btData.btSnapGUID) {
      btDataCopy.btSnapGUID = btData.btSnapGUID;
    }

    return btDataCopy;
  }


  var i;
  var id = 1;
  var parentNodeMap = {};
  var btDataMap = {};
  var nodeQueue = [];
  var reverseQueue = [];

  rootNode._id = id++;
  nodeQueue.push(rootNode);

  while(nodeQueue.length > 0) {
    var node = nodeQueue.shift();

    reverseQueue.unshift(node);

    if(node.procCallElemBTData) {
      node.procCallElemBTData.forEach(function(btData) {
        btDataMap[node._id + ':' + createBtDataUid(btData)] = btData;
      });
    }

    for(i = node.children.length - 1; i >= 0; i--) {
      var childNode = node.children[i];

      childNode._id = id++;

      parentNodeMap[childNode._id] = node;

      nodeQueue.unshift(childNode);
    }
  }

  reverseQueue.forEach(function(node) {
    var parentNode = parentNodeMap[node._id];

    if(node.procCallElemBTData && parentNode) {
      if(!parentNode.procCallElemBTData) {
        parentNode.procCallElemBTData = [];
      }

      node.procCallElemBTData.forEach(function(btData) {
        var parentBtDataKey = parentNode._id + ':' + createBtDataUid(btData);

        var parentBtData = btDataMap[parentBtDataKey];
        if(!parentBtData) {
          parentBtData = cloneBtData(btData);
          parentBtData._synthetic = true;
          btDataMap[parentBtDataKey] = parentBtData;
          parentNode.procCallElemBTData.push(parentBtData);
        }
        else if (parentBtData._synthetic) {
          parentBtData.count += btData.count;
          parentBtData.totalTimeTaken += btData.totalTimeTaken;
        }
      });
    }
  });

  reverseQueue.forEach(function(node) {
    delete node._id;

    if(node.procCallElemBTData) {
      node.procCallElemBTData.forEach(function(btData) {
        delete btData._synthetic;
      });
    }
  });
}


ProcessScanner.prototype.postProcessCallGraph = function(processSnapshot, callContextMap, durationSeconds) {
  var self = this;

  var callElements = processSnapshot.processCallGraph.callElements;

  if(callElements && callElements.length > 0) {
    var rootNode = self.convertListToTree(callElements);

    self.calculateCpuTime(rootNode, durationSeconds);

    self.populateCallContext(rootNode, callContextMap);

    self.mergeThreadPaths(rootNode);

    self.removeIdleNode(rootNode);

    if(self.agent.opts.excludeAgentFromCallGraph) {
      self.removeAgentNodes(rootNode);
    }

    self.backpropagateCallContext(rootNode);

    callElements = self.convertTreeToList(rootNode);

    // remove root node
    var root = callElements[0];
    if (root && root.klass == "(global)" && root.method == "(root)") {
      processSnapshot.processCallGraph.numOfRootElements = root.numChildren;
      callElements.splice(0, 1);
    }

    processSnapshot.processCallGraph.callElements = callElements;
  }
}
